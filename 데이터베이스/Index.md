## 1. 인덱스란?

- 인덱스란 추가적인 쓰기 작업과 저장공간을 활용하여 데이터베이스 테이블의 검색속도를 향상시키기 위한 자료 구조이다.
- 책에서 특정 내용을 찾고자 할때 찾기 편하도록 책 뒷편에 색인을 참조해서 아! 몇페이지에 있구나 하고 해당페이지를 바로 들여다 보게 되는데 이때 **색인이 데이터베이스의 인덱스와 같다.**
- 데이터베이스의 테이블에 모든 데이터를 하나하나 검색하면 시간이 오래 걸리기때문에 **데이터와 데이터의 위치를 포함한 자료구조**를 생성하여 빠르게 조회할 수 있도록 하고있다.
- 인덱스 사용시 데이터를 조회하는 SELECT 뿐만아니라 UPDATE, DELETE의 성능 또한 향상된다. 해당연산을 수행하려면 대상을 조회해야하기 때문

---

## 2. 인덱스의 관리

- 인덱스는 항상 최신의 정렬된 상태로 유지해야만 원하는 값을 빠르게 탐색할 수 있다.
- 때문에 INSERT, DELETE, UPDATE가 수행되면 인덱스에도 추가적으로 연산을 해주어야한다.
- INSERT: 새로운 데이터에 대한 인덱스를 추가
- DELETE: 삭제하는 데이터의 인덱스도 사용하지 않는다는 작업 진행
- UPDATE: 기존의 인덱스를 사용하지 않음처리, 갱신된 데이터에 대한 인텍스 추가

---

## 3. 인덱스의 장, 단점

### 1. 장점

- 테이블을 조회하는 속도와 그에따른 성능을 향상시킬 수 있다.
- 시스템의 부하는 줄여줄 수 있다.

### 2. 단점

- 인덱스를 관리하기위해 데이터베이스에 별도의 저장공간이 필요함
- 인덱스 관리를 위한 추가작업이 필요함
- 잘못사용하면 오히려 성능이 저하됨
  - CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 적용하면 인덱스의 크기가 커져 성능이 오히려 저하되는 역요화가 있음
  - DELETE, UPDATE의 경우 기존의 인덱스를 삭제하는 것이 아닌 사용하지 않음 처리를 하기 때문에 실제 데이터보다 인덱스가 몇배는 커지게 되 성능이 오히려 떨어짐

---

## 4. 인덱스를 사용하면 좋은경우

- 규모가 큰 테이블
- INSERT, UPDATE, DELETE 작업이 자주 발생하지 않는 컬럼
- JOIN, WHERE, ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

---

## 5. 인덱스의 자료구조

### 1. 해시 테이블

- 해시 테이블은 Key, Value로 데이터를 저장하는 자료구조로 빠른 데이터 검색이 필요할때 유용하다.
- Key를 이용해 고유한 인덱스를 생성해 그 인덱스에 저장된 값을 꺼내오는 구조임
- 해시 테이블 기반의 인덱스는 데이터로 컬럼의 값, 데이터의 위치를 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현한다.
- 시간복잡도가 O(1)로 매우빠른 검색속도를 가진다.
- BUT, 해시테이블은 등호 연산에 특화되어 있어 부등호 연산이 잦은 데이터베이스 검색에는 적합하지 않다.

---

### 2. B-Tree

- 이진트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화 시킨것
- **균형잡힌 확장된 이진 탐색 트리이므로 O(logN)의 시간 복잡도**를 가진다.
- 최대 M개의 자식을 가질 수 있는 B트리를 M차 B트리라고 한다
- 노드의 자료수가 N이면, 자식수는 N+1이어야 한다.
- 각 노드의 자료는 정렬된 상태여야한다.
- 루트노드는 적어도 2개 이상의 자식을 가져야한다.
- 루트노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가지고있어야한다.
- 외부 노드로 가는 경로의 길이는 모두 같다.
- 입력 자료는 중복될 수 없다.

### 3. B+Tree

- DB 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
- 리프 노드 : 실제 데이터가 저장되는 노드
- 논리 노드 : 리프노드까지의 경로 역할을 하는 노드
- 루트 노드 : 경로의 출발점 노드
- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
- 리프노드들은 LinkedList로 연결되어있다.
- 데이터노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
- 데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다.
- 이러한 이유로 **B Tree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B Tree를 인덱스에 맞게 최적화**하였다.
- B+ Tree는 O(log2N)의 시간복잡도를 가진다.

---

## 6. 카디널리티(C**ardinality**)

- 카디널리티가 높을수록 인덱스 설정에 좋은 컬럼
- 카디널리티란 컬럼 데이터의 중복정도를 나타낸다.
- 이름, 주민등록번호를 예들들면 이름은 중복되는 사람이 많아서 카디널리티가 낮다.
- 반면 주민등록번호는 중복되는 경우가 거의 없기 때문에 카디널리티가 높다고 할 수 있다.
- 인덱스는 키로 들어가는 값이 정렬되어 있음,
- "A"를 조회할 경우 동일한 "A"라는 이름의 데이터가 연달아 나오다가 "B"라는 이름이 나온다면 더 이상 "A" 조회를 하지 않기 때문에 카디널리티가 높을수록 인덱스의 탐색양이 줄어든다.

---

## 7. 기타

### 1. 클러스터드 인덱스

- 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
- 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다.
- 데이터 삽입, 삭제 발생 시 **순서를 유지**하기 위해 **데이터를 재정렬**해야한다.
- 한 개의 릴레이션에 **하나의 인덱스만 생성 가능**

---

### 2. 넌클러스터드 인덱스

- 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
- 데이터를 검색하기 위해서는 먼저 인덱스를 검색하여 실제 데이터 위치를 확인해야 하므로 **클러스터드 인덱스에 비해 검색 속도가 떨어진다.**
- 한 개의 릴레이션에 여러 인덱스를 만들 수 있다.

---

## 8. 정리

- 인덱스는 데이터가 저장된 **물리적 구조**와 밀접한 관계가 잇다.
- 인덱스는 레코드가 저장된 물리적 구조에 **접근하는 방법**을 제공한다.
- 레코드의 삽입과 삭제가 빈번하게 일어나는 경우, 인덱스의 개수를 최소로 하는 것이 효율적이다.
- 인덱스가 없으면 특정한 값을 찾기위해 모든 데이터 페이지를 확인하는 **TABlE SCAN**이 발생한다.
- **기본키**를 위한 인덱스를 **기본 인덱스**라 하고, 기본 인덱스가 아닌 인덱스들을 **보조 인덱스**라고 한다. 대부분의 관계형 데이터베이스 관리 시스템에서는 모든 기본키에 대해서 자동적으로 기본 인덱스를 생성한다.
- 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성하는 인덱스를 **클러스터드 인덱스**라고 한다.
